Senin İçin En Şık Mimari: Interface Kullanımı

public interface ISeatManager {
    void createSeating(Plane plane); // Koltuk düzenini oluşturur
    int countAvailableSeats(Plane plane); // Boş koltukları sayar
    boolean isSeatAvailable(Plane plane, String seatNum); // Koltuk boş mu?
}

public class SeatManagerImpl implements ISeatManager {

    @Override
    public void createSeating(Plane plane) {
        // Map yapısını doldurma kodların buraya gelecek
    }

    @Override
    public int countAvailableSeats(Plane plane) {
        // Map'i dönüp boş olanları sayan kodların buraya gelecek
        return (int) plane.getSeatMap().values().stream()
                          .filter(s -> !s.isReserved()).count();
    }

    @Override
    public boolean isSeatAvailable(Plane plane, String seatNum) {
        Seat seat = plane.getSeatMap().get(seatNum);
        return seat != null && !seat.isReserved();
    }
}

Hangisi Ne Zaman?
    Normal Class: Sadece bir iş yapacaksa ve alternatif bir yöntemi yoksa kullanılır.
    Interface (Arayüz): "Bu iş birimi neler yapabilir?" sorusuna cevap verir. Sadece metodların imzasını (adını) yazar, gövdesini yazmazsın. (Projen için en mantıklısı budur).
    Abstract Class (Soyut Sınıf): Eğer birden fazla manager olacaksa ve bunların ortak kodları (örneğin hepsi log tutacaksa) varsa kullanılır.
    Extend: Is-a ilişkisi olduğunda.



---------------------------------------------------------------------------------------------
ODEV NASIL YAPILMALI?
Ödev dokümanını ve sana verilen tavsiyeyi incelediğimde, kafanın karışması çok normal. Yazılım dünyasında "gereğinden fazla mühendislik" (over-engineering) denilen bir durum vardır. Sana verilen tavsiye teorik olarak doğru olsa da, senin projende neyin **zorunlu** neyin **mantıklı** olduğunu netleştirelim.

### 1. Structure (Yapı) Karmaşasını Çözelim

Sana gelen tavsiyedeki "Manager'ı interface yap, işi yapan başka class olsun" mantığı aslında işi başka bir class'a yaptırmak değil, **"ne yapılacağını"** (Interface) **"nasıl yapılacağından"** (Manager Class) ayırmaktır.

Proje dosyanın  gereksinimlerine göre en ideal ve puan kaybettirmeyecek yapı şudur:

#### **A. Model / Entity Katmanı (Sadece Veri)**

Bu sınıflar sadece veri tutar. Dokümanda tablo olarak verilen `Plane`, `Flight`, `Seat`, `Passenger` gibi sınıflardır.

* **Kural:** Bu sınıflar bir şeyi `extends` etmek zorunda değil.
*
**OOP:** Burada **Encapsulation** (private değişkenler ve getter/setter) kullanırsın.



#### **B. Service / Manager Katmanı (İş Mantığı)**

Doküman 1.c bölümünde `FlightManager`, `SeatManager` ve `ReservationManager` sınıflarını "Services and Managers" altında toplamış.

* **Senin sorun:** "Interface yapıp işi başkasına yaptırmak saçma geliyor."
* **Çözüm:** Eğer projen çok büyük değilse, her Manager için bir Interface yazmak zorunda değilsin. Ancak doküman **"Abstraction"** (Soyutlama) prensibini uygulamanı istiyor.


* **Öneri:** Sadece ana işi yapan `ReservationManager` veya `FlightManager` için birer Interface (örneğin `IFlightService`) tanımlayıp, Manager sınıfında bunu `implements` edersen "Abstraction" maddesinden tam puan alırsın.

---

### 2. Kalıtım (Inheritance) Nerede Olmalı?

Manager sınıflarını birbirine `inherit` (kalıtım) ettirmek gerçekten saçma olur, çünkü bir `FlightManager` bir `SeatManager` değildir.

Dokümanda **Inheritance** prensibini en mantıklı şu iki yerden birinde kullanmalısın:

1. **Bilet Tipleri (En Mantıklısı):** `Ticket` ana sınıf olur; `EconomyTicket` ve `BusinessTicket` ondan türer.


2. **Kullanıcı Tipleri:** `User` ana sınıf olur; `Passenger` ve `Staff` (veya Admin) ondan türer.



---

### 3. Önerilen Klasör (Package) Yapısı

Projeni şu şekilde organize edersen hem UML diyagramın  çok temiz çıkar hem de hocan aradığı her şeyi bulur:

*
**`com.havayolu.models`**: `Flight`, `Plane`, `Seat`, `Passenger`, `Reservation`, `Ticket` (Veri sınıfları).


*
**`com.havayolu.services`**: `IFlightService`, `IReservationService` (Interface'ler).


*
**`com.havayolu.managers`**: `FlightManager`, `ReservationManager`, `SeatManager` (İşi yapan asıl kodlar).


*
**`com.havayolu.utils`**: `CalculatePrice` (Fiyat hesaplama mantığı), `ReportGenerator` (Multithreading raporlama).


*
**`com.havayolu.gui`**: Arayüz sınıfları (Swing veya JavaFX).



---

### 4. Kritik Uyarı: Multithreading ve Senkronizasyon

Doküman sende çok spesifik bir şey istiyor: **90 yolcunun aynı anda (threadlerle) koltuk seçmesi**.

* Burada `ReservationManager` sınıfında bir metodun olacak.
* Eğer arayüzde "Synchronized" seçiliyse, metodun başına `synchronized` anahtar kelimesini koyacaksın.


* Böylece iki kişi aynı koltuğu aynı anda rezerve edemeyecek.

### Özetle Ne Yapmalısın?

1. Manager'larını birer **Interface**'e bağla (Abstraction için).


2. Bilet veya Kullanıcı sınıflarında **Inheritance** kullan (Kalıtım için).


3. Tüm değişkenlerini `private` yap (Encapsulation için).


4. Manager sınıflarının içine verileri dosyaya kaydedip okuyan metodlar ekle (Permanent storage için).

---------------------------------------------------------------------------------------------
INTERFACE ILE ABSTRACTION

    interface Payment {
        void pay(double amount);
    }

    Payment p = new CreditCardPayment();
    p.pay(100);

*Interface:
->Sadece ne yapılır
->“Bunu yapabilen her şey”
->Multiple inheritance var

*****************************
ABSTRACT CLASSLA ABSTRACTION

    abstract class Payment {
        abstract void pay(double amount);

        void log() {
            System.out.println("Payment logged");
        }
    }

    Payment p = new CreditCardPayment();
    p.pay(100);

*Abstract class:
->Ne yapılır + ortak nasıl yapılır
->“Bu şeydir”
->State + constructor olabilir



